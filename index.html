<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feelify</title>
    <style>
        /* --- Base Styles --- */
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            color: #10B981; /* Emerald Green */
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        /* --- Title --- */
        .title-container {
            margin: 50px 0;
            position: relative;
            width: 800px; /* Adjust as needed */
            height: 200px; /* Adjust as needed */
            max-width: 90%; /* Ensure responsiveness */
        }

        .title-path {
            fill: none;
            stroke: rgba(16, 185, 129, 0.15); /* Lighter, subtle stroke */
            stroke-width: 2;
            font-family: system-ui, -apple-system; /* Modern font */
            font-weight: 200; /* Lighter weight */
        }

        .glow-path {
            fill: none;
            stroke: #10B981; /* Emerald Green */
            stroke-width: 2;
            filter: url(#glow);
        }

        /* --- Input --- */
        .input-container {
            width: 100%;
            max-width: 500px; /* Comfortable width */
            padding: 20px;
            position: relative; /* For potential future additions */
            z-index: 2; /* Ensure it's above potential background elements */
        }

        input[type="text"] {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            background: transparent; /* Blend with background */
            border: 2px solid #10B981; /* Emerald Green border */
            border-radius: 8px;
            color: #10B981; /* Emerald Green text */
            transition: all 0.3s ease;
            outline: none; /* Remove default outline */
            box-sizing: border-box; /* Include padding/border in width */
        }

        input[type="text"]:focus {
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5); /* Subtle glow on focus */
            border-color: #10B981; /* Keep border color consistent */
        }

        input[type="text"]::placeholder {
            color: rgba(16, 185, 129, 0.5); /* Lighter placeholder text */
        }

        /* --- Suggestions --- */
        .suggestions-container {
            width: 100%;
            max-width: 1200px; /* Wider container for more cards */
            margin: 20px auto 40px; /* Center and add spacing */
            padding: 0 20px; /* Padding on sides */
            display: grid;
            /* Responsive grid: fills columns with cards min 250px wide */
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px; /* Space between cards */
            box-sizing: border-box;
        }

        /* --- Song Card --- */
        .song-card {
            background: rgba(16, 185, 129, 0.05); /* Very subtle background */
            border: 1px solid rgba(16, 185, 129, 0.2); /* Faint border */
            border-radius: 12px; /* Softer corners */
            padding: 20px;
            transition: all 0.3s ease; /* Smooth transitions */
            cursor: pointer;
            /* Add accessibility roles */
            role: button;
            tabindex: 0; /* Make it focusable */
        }

        .song-card:hover, .song-card:focus { /* Add focus style for accessibility */
            transform: translateY(-2px); /* Slight lift effect */
            background: rgba(16, 185, 129, 0.1); /* Slightly darker background */
            border-color: rgba(16, 185, 129, 0.4); /* Stronger border */
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.1); /* Subtle shadow */
            outline: none; /* Remove default focus outline if custom style is applied */
        }

        .song-title { /* Combined styles for title */
            font-size: 18px;
            color: rgba(16, 185, 129, 1); /* Full color title */
            margin: 0 0 8px 0; /* Spacing below title */
            font-weight: 600; /* Bolder title */
        }

        .song-artist { /* Renamed from .artist for consistency */
            font-size: 16px;
            color: rgba(16, 185, 129, 0.8); /* Slightly faded artist */
            margin: 0 0 12px 0; /* Spacing below artist */
        }

        .song-details {
            font-size: 14px;
            color: rgba(16, 185, 129, 0.6); /* More faded details */
            margin: 0;
            line-height: 1.4; /* Improve readability */
        }

        /* --- UI Feedback --- */
        .error-message {
            text-align: center;
            padding: 20px;
            color: rgba(255, 99, 71, 0.8); /* Tomato color for errors */
            font-size: 16px;
            background: rgba(255, 99, 71, 0.1); /* Subtle error background */
            border-radius: 8px;
            margin: 20px auto;
            max-width: 400px;
            animation: fadeIn 0.3s ease-out;
            grid-column: 1 / -1; /* Span across all grid columns */
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: rgba(16, 185, 129, 0.9); /* Loading text color */
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px; /* Space between text and spinner */
            grid-column: 1 / -1; /* Span across all grid columns */
        }

        /* Use only the spinner animation */
        .loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid rgba(16, 185, 129, 0.3); /* Lighter border */
            border-top: 2px solid #10B981; /* Main color for spinning part */
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- Version Counter --- */
        .version-counter {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-size: 12px;
            color: rgba(16, 185, 129, 0.5); /* Subtle color */
            font-family: monospace; /* Monospace for version */
            z-index: 998; /* Keep above most elements */
        }

        /* --- Accessibility --- */
        .visually-hidden { /* Hide element visually but keep for screen readers */
            position: absolute;
            left: -10000px;
            top: auto;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div class="title-container">
        <svg viewBox="0 0 800 200" preserveAspectRatio="xMidYMid meet">
            <defs>
                <filter id="glow">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="2" result="blur" />
                    <feComposite in="SourceGraphic" in2="blur" operator="over" />
                </filter>
                <mask id="hover-mask">
                    <rect width="100%" height="100%" fill="white"/>
                    <circle id="mask-circle" r="50" cx="-100" cy="-100" fill="black"/>
                </mask>
            </defs>
            <text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle"
                  font-size="140px" class="title-path">
                Feelify
            </text>
            <text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle"
                  font-size="140px" class="glow-path" mask="url(#hover-mask)">
                Feelify
            </text>
        </svg>
    </div>

    <div class="input-container">
        <!-- Add accessible label -->
        <label for="feelInput" class="visually-hidden">How are you feeling?</label>
        <input type="text" id="feelInput" placeholder="How are you feeling? (Press Enter)" autofocus>
    </div>

    <!-- Add aria-live for screen reader announcements -->
    <div class="suggestions-container" id="suggestions" aria-live="polite"></div>

    <!-- Removed Diagnostics and Debug Panels -->
    <div class="version-counter">v4.0-Aesthetics</div> <!-- Kept version -->

    <script>
        // --- Configuration ---
        // !! EXTREME SECURITY WARNING !!
        // Hardcoding API keys in client-side code is HIGHLY INSECURE and exposes your key.
        // Anyone viewing the page source can steal and use it, potentially incurring costs.
        // Use this ONLY for personal, local testing. Replace with a backend proxy for production.
        const AIMLAPI_KEY = '92494b76982f48a49b18266ede6e4af0'; // Your key is here
        const AIMLAPI_BASE_URL = 'https://api.aimlapi.com/v1';
        const AIMLAPI_MODEL = 'gpt-4o'; // Or another model supported by AIMLAPI

        // --- DOM Elements ---
        const titleContainer = document.querySelector('.title-container');
        const maskCircle = document.querySelector('#mask-circle');
        const suggestionsContainer = document.getElementById('suggestions');
        const feelInput = document.getElementById('feelInput');
        // Removed selectors for diagnostics and debug panels

        // --- State Variables ---
        let currentSuggestions = [];

        // --- Error Handling & Retry Configuration ---
        const MAX_RETRIES = 3; // Max retries specifically for the API call function
        const RETRY_DELAY = 1000; // Initial delay, increases exponentially

        // --- Utility Functions ---
        async function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Removed updateDiagnostics, updateDebugPanel, updateDebugIssue, runInitialChecks functions

        // --- Core Logic ---

        async function getSongSuggestions(input) {
            // Simplified attempt structure without local fallback
            const attemptFns = [
                { name: 'AIMLAPI', fn: tryAIMLAPI },
                { name: 'Cached Results', fn: tryCachedResults },
                { name: 'Emergency Mode', fn: tryEmergencyMode }
            ];

            // Removed debug/diagnostics resets

            for (let i = 0; i < attemptFns.length; i++) {
                const attempt = attemptFns[i];
                try {
                    // Removed diagnostics update for 'active'
                    console.log(`Attempting: ${attempt.name}`);
                    const result = await attempt.fn(input); // Pass input to the function
                    // Removed diagnostics update for 'success'

                    // Cache successful results from API (first attempt)
                    if (i === 0 && result && result.length > 0) {
                         try {
                            // Use a consistent key format for caching
                            const cacheKey = `songs_${input.toLowerCase().trim()}`;
                            localStorage.setItem(cacheKey, JSON.stringify(result));
                            console.log(`Cached results successfully for key: ${cacheKey}`);
                         } catch (e) {
                            console.warn('Failed to cache results:', e.message);
                         }
                    }
                    return result; // Return the successful result
                } catch (error) {
                    console.error(`${attempt.name} failed:`, error);
                    // Removed diagnostics update for 'failed'
                    // Continue to the next fallback method in the loop
                }
            }
            // If all attempts failed
            throw new Error('All attempts to fetch suggestions failed.');
        }

        async function tryAIMLAPI(input) {
            // Check if API key is placeholder
            if (!AIMLAPI_KEY || AIMLAPI_KEY === '<YOUR_AIMLAPI_KEY>') {
                 throw new Error('AIMLAPI Key is not configured.');
            }

            // Removed debug issue updates

            // *** MODIFIED: Enhanced system prompt to focus on feeling ***
            const systemPrompt = `You are a helpful assistant that suggests songs based on a user's mood.
Focus on the underlying emotion or vibe conveyed by the user's input, not just the literal words used. Interpret the feeling and find songs that match that mood.
Respond ONLY with a valid JSON array of song objects. Each object must have the following keys: "title", "artist", "genre", and "year".
Do not include any introductory text, explanations, markdown formatting (like \`\`\`json), or anything else outside the JSON array.
Example format: [{"title": "Song Title", "artist": "Artist Name", "genre": "Pop", "year": "2020"}]`;

            const apiUrl = `${AIMLAPI_BASE_URL}/chat/completions`;

            for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
                try {
                    console.log(`AIMLAPI attempt ${attempt}/${MAX_RETRIES}`);
                    // Removed diagnostics update for retry attempt

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${AIMLAPI_KEY}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: AIMLAPI_MODEL,
                            messages: [
                                { role: "system", content: systemPrompt },
                                // *** MODIFIED: Request 36 songs ***
                                { role: "user", content: `Suggest 36 songs for someone feeling: ${input}` }
                            ],
                            // temperature: 0.7, // Optional: Adjust creativity
                            // *** ADDED: Set max_tokens for potentially longer response ***
                            max_tokens: 2500
                        })
                    });

                    // Removed debug issue updates for connection/CORS

                    if (!response.ok) {
                        let errorData = { message: `API request failed with status ${response.status}` };
                        try {
                            errorData = await response.json();
                            // Removed debug issue update for parsing error response
                        } catch (e) {
                             console.error("Failed to parse error response body:", response.statusText);
                             // Removed debug issue update for parsing error response
                        }

                        const errorMessage = errorData?.error?.message || errorData?.detail || errorData.message || `HTTP error ${response.status}`;
                        console.error(`AIMLAPI error (${response.status}):`, errorMessage, errorData);

                        if (response.status === 401 || response.status === 403) {
                            // Removed debug issue update for API key
                            throw new Error(`API Key Invalid or Permission Denied: ${errorMessage}`);
                        } else if (response.status === 429) {
                            // Removed debug issue update for rate limit
                            if (attempt < MAX_RETRIES) {
                                const waitTime = RETRY_DELAY * Math.pow(2, attempt -1);
                                console.log(`Rate limited. Retrying in ${waitTime}ms...`);
                                // Removed diagnostics update for rate limit retry
                                await delay(waitTime);
                                continue; // Retry
                            } else {
                                throw new Error(`Rate limit exceeded after ${MAX_RETRIES} attempts.`);
                            }
                        } else {
                            // Removed debug issue update for API error
                            throw new Error(`API Error (${response.status}): ${errorMessage}`);
                        }
                    }

                    // If response is OK
                    // Removed debug issue updates for API key/rate limit

                    let responseData;
                    try {
                        responseData = await response.json();
                        // Removed debug issue update for parsing success response
                    } catch (e) {
                        // Removed debug issue update for parsing success response
                        throw new Error('Invalid JSON response from API');
                    }

                    const aiContent = responseData?.choices?.[0]?.message?.content;
                    if (!aiContent) {
                        // Removed debug issue update for response format
                        throw new Error('Invalid response structure from API');
                    }

                    try {
                        // Attempt to clean potential markdown ```json ... ```
                        const cleanedContent = aiContent.trim().replace(/^```json\s*|```$/g, '');
                        const songs = JSON.parse(cleanedContent);
                         if (!Array.isArray(songs)) {
                            // Removed debug issue update for response format
                            throw new Error('AI did not return a valid JSON array');
                         }
                        // Removed debug issue update for response format
                        return validateSongData(songs); // Validate and return
                    } catch (e) {
                        console.error("Failed to parse AI content as JSON:", aiContent, e);
                        // Removed debug issue update for response format
                        throw new Error('Failed to parse song data from AI response');
                    }

                } catch (error) {
                    console.error(`AIMLAPI attempt ${attempt} failed:`, error);
                    // Removed debug issue updates for network/API key/rate limit

                    if (attempt === MAX_RETRIES) {
                        throw error; // Throw the final error after all retries
                    }
                     // Only retry on rate limit errors specifically
                     if (!error.message.includes('Rate limit') && !error.message.includes('429')) {
                         throw error; // Fail fast on non-retriable errors for this attempt
                     }
                     // If rate limited, the 'continue' handles the retry delay.
                }
            }
             // Should not be reached if MAX_RETRIES > 0, but acts as a safeguard
             throw new Error('AIMLAPI failed after all retries.');
        }


        async function tryCachedResults(input) {
            try {
                // Use a consistent key format for retrieval
                const cacheKey = `songs_${input.toLowerCase().trim()}`;
                const cached = localStorage.getItem(cacheKey);
                if (cached) {
                    // Removed debug issue update
                    console.log(`Using cached results for key: ${cacheKey}`);
                    const songs = JSON.parse(cached);
                    // Removed debug issue update
                    // Re-validate cached data in case format changed or cache got corrupted
                    return validateSongData(songs);
                } else {
                    // Removed debug issue update
                    throw new Error(`No cached results found for key: ${cacheKey}`);
                }
            } catch (e) {
                 // Removed debug issue updates
                 console.error("Error retrieving or parsing cached results:", e);
                 throw new Error('Failed to retrieve or use cached results');
            }
        }

        // Removed tryLocalFallback function

        function tryEmergencyMode(input) {
            // Removed debug issue update
            console.log('Activating emergency mode.');
            // Return a single, clearly marked emergency song
            return validateSongData([{
                title: 'Emergency Song',
                artist: 'System Fallback',
                genre: 'Fallback',
                year: new Date().getFullYear().toString() // Current year
            }]);
        }

        function validateSongData(data) {
            // Ensures the data has the expected structure, providing defaults
            if (!Array.isArray(data)) {
                 console.error("Validation Error: Data is not an array", data);
                 // Removed debug issue update
                 return []; // Return empty array as a safe fallback
            }
            const validated = data.map(song => ({
                title: song?.title || 'Unknown Title',
                artist: song?.artist || 'Unknown Artist',
                genre: song?.genre || 'Unknown Genre',
                year: String(song?.year || 'N/A') // Ensure year is a string
            })).filter(song => song.title !== 'Unknown Title'); // Filter out entries that are completely invalid

             if (validated.length !== data.length) {
                 console.warn("Some song entries were filtered during validation due to missing titles.");
                 // Removed debug issue update
             } else if (validated.length > 0) {
                 // Only mark as OK if validation passed without warnings AND data exists
                 if (validated.length === data.length) {
                    // Removed debug issue update
                    console.log("Song data structure appears valid.");
                 }
             } else if (data.length > 0 && validated.length === 0) {
                 // If the original data had items but validation removed them all
                 // Removed debug issue update
                 console.error("All song entries failed validation (e.g., missing titles).");
             }

            return validated;
        }

        // --- UI Functions ---
        function displaySuggestion(song) {
            const div = document.createElement('div');
            div.className = 'song-card';
            div.setAttribute('role', 'button'); // Accessibility
            div.setAttribute('tabindex', '0');  // Accessibility
            div.innerHTML = `
                <h3 class="song-title">${song.title}</h3>
                <p class="song-artist">${song.artist}</p>
                <p class="song-details">${song.genre} • ${song.year}</p>
            `;
            // Add subtle fade-in animation per card (optional)
            div.style.opacity = '0';
            div.style.transition = 'opacity 0.5s ease';
            suggestionsContainer.appendChild(div);
            // Trigger reflow to ensure transition works
            requestAnimationFrame(() => {
                div.style.opacity = '1';
            });
        }

        function displayLoading() {
            suggestionsContainer.innerHTML = `
                <div class="loading">Finding the perfect songs for your mood</div>
            `;
             suggestionsContainer.setAttribute('aria-busy', 'true'); // Accessibility: Indicate loading
        }

        function displayError(message) {
             // Basic XSS protection
             const safeMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
             suggestionsContainer.innerHTML = `<div class="error-message">${safeMessage}</div>`;
             suggestionsContainer.removeAttribute('aria-busy'); // Accessibility: Loading finished (with error)
        }

        function clearSuggestions() {
            suggestionsContainer.innerHTML = '';
            suggestionsContainer.removeAttribute('aria-busy'); // Accessibility: No longer busy
        }


        async function handleInput() {
            const input = feelInput.value.trim();
            if (input.length === 0) {
                clearSuggestions();
                return;
            }

            feelInput.disabled = true; // Prevent multiple submissions
            displayLoading();

            try {
                currentSuggestions = await getSongSuggestions(input);
                clearSuggestions(); // Clear loading message

                if (currentSuggestions && currentSuggestions.length > 0) {
                    // Check if it was the emergency song specifically
                    if (currentSuggestions.length === 1 && currentSuggestions[0].title === 'Emergency Song') {
                         displayError('Could not fetch suggestions. Displaying fallback.');
                    } else {
                         currentSuggestions.forEach(displaySuggestion);
                    }
                } else {
                    // Handle cases where API returns empty array or validation fails completely
                    displayError('No songs found for this mood. Try expressing your feeling differently.');
                }
            } catch (error) {
                console.error('Error in handleInput:', error);
                let userErrorMessage = error.message || 'An unexpected error occurred.';
                // User-friendly error messages (simplified without debug context)
                if (userErrorMessage.includes('Failed to fetch') || userErrorMessage.includes('Network error')) {
                    userErrorMessage = 'Unable to connect. Please check your internet connection and try again.';
                } else if (userErrorMessage.includes('Rate limit exceeded')) {
                    userErrorMessage = 'Feeling too popular! Too many requests right now. Please wait a moment and try again.';
                } else if (userErrorMessage.includes('API Key Invalid') || userErrorMessage.includes('Authentication failed') || userErrorMessage.includes('AIMLAPI Key is not configured')) {
                    userErrorMessage = 'There seems to be an issue connecting to the suggestion service (Auth/Config). Please try again later.';
                } else if (userErrorMessage.includes('All attempts to fetch suggestions failed')) {
                     userErrorMessage = 'Could not find suggestions using any method. Please try again later.';
                } else if (userErrorMessage.includes('Failed to parse song data') || userErrorMessage.includes('Invalid response structure') || userErrorMessage.includes('AI did not return a valid JSON array')) {
                     userErrorMessage = 'Received an unexpected response from the suggestion service. Please try again.';
                } else if (userErrorMessage.includes('Failed to retrieve or use cached results')) {
                     userErrorMessage = 'There was an issue retrieving cached suggestions. Trying to fetch fresh ones.'; // Less alarming than a generic error
                     // Maybe attempt fetch again here, or just let it fail to emergency mode if API also fails
                }


                displayError(userErrorMessage);
            } finally {
                feelInput.disabled = false; // Re-enable input
                // Keep focus unless there was an error message displayed
                if (!suggestionsContainer.querySelector('.error-message')) {
                   feelInput.focus();
                }
                 suggestionsContainer.removeAttribute('aria-busy'); // Ensure busy state is removed
            }
        }

        // --- Event Listeners ---

        // Title Glow Effect
        titleContainer.addEventListener('mousemove', (e) => {
            const rect = titleContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            maskCircle.setAttribute('cx', x);
            maskCircle.setAttribute('cy', y);
        });
        titleContainer.addEventListener('mouseleave', () => {
            maskCircle.setAttribute('cx', -100); // Move mask off-screen
            maskCircle.setAttribute('cy', -100);
        });

        // Input Handling (Enter Key)
        feelInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent default form submission if wrapped in form
                handleInput();
            }
        });

        // --- Initialization ---
        // Removed calls to runInitialChecks, updateDebugPanel, updateDiagnostics

    </script>
</body>
</html>
